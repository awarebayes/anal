\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Arch \cite{ubuntu} Linux \cite{linux} x86\_64.
	\item Память: 16 GiB.
	\item Процессор: AMD Ryzen 7 3800X 3.9 GHz \cite{intel}.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Демонстрация работы программы}


\img{140mm}{example}{Пример работы программы}
На рисунке \ref{img:example} представлен результат работы программы.


\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции process\_time() из библиотеки time языка Python. Данная функция всегда возвращает значения времени, а имеено сумму системного и пользовательского процессорного времени текущего процессора, типа float в секундах.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины слов проводились 100 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова.

Результаты замеров приведены в таблице \ref{tab:time} (время в мкс).

\begin{table}[!ht]
    \centering
	\caption{\label{tab:time}Результаты замеров времени.}
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
        n & Л-р & Л-м & Л-рм & ЛД-р & ЛД-м & ЛД-рм \\ \hline
		1 & 0.003 & 0.004 & 0.003 & 0.003 & 0.003 & 0.005 \\ \hline
        2 & 0.01 & 0.009 & 0.005 & 0.009 & 0.007 & 0.01 \\ \hline
        3 & 0.038 & 0.017 & 0.009 & 0.045 & 0.01 & 0.016 \\ \hline
        4 & 0.176 & 0.022 & 0.01 & 0.173 & 0.012 & 0.024 \\ \hline
        5 & 0.889 & 0.032 & 0.014 & 0.956 & 0.018 & 0.057 \\ \hline
        6 & 4.33 & 0.041 & 0.017 & 4.637 & 0.024 & 0.046 \\ \hline
    \end{tabular}
\end{table}


На рисунке \ref{img:figure6} представлен график сравнения рекурсивных реализаций алгоритмов поиска расстояния Дамерау-Левенштейна с использованием кеша и без. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 6).

На рисунке \ref{img:figure5} представлен график сравнения рекурсивных реализаций алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 7).

На рисунке \ref{img:figure4} представлен график сравнения матричной реализаций алгоритма поиска расстония Левенштейна и рекурсивного алгоритма поиска расстояния Левенштейна с использованием кеша.

\img{120mm}{figure2}{Сравнения рекурсивных алгоритмов поиска расстояния Дамерау-Левенштейна с использованием кеша и без}
\img{120mm}{figure1}{Сравнения рекурсивных алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна}
\img{120mm}{figure4}{Сравнения матричного алгоритма поиска расстояния Дамерау-Левенштейна и рекурсивного алгоритма поиска расстояния Дамерау-Левенштейна с использованием кеша}

 
\section{Использование памяти}

Алгоритмы нахождения расстояний Левенштейна и Дамерау -- Левенштейна не отличаются друг от друга с точки зрения использования памяти, поэтому достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций данных алгоритмов.

Пусть длина строки S1 - n, длина строки S2 - m, тогда затраты памяти на приведенные выше алгоритмы будут следующими:
\begin{itemize}
	\item матричный алгоритм поиска расстояния Левенштейна:\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item матрица - ((m + 1) * (n + 1)) * sizeof(int)
		\item текущая строка матрицы - (n + 1) * sizeof(int)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  3 * sizeof(int)
	\end{itemize}
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящий строк.

\begin{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна (для каждого вызова):\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  2 * sizeof(int)
		\item адрес возврата
	\end{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна с использованием кеша (для каждого вызова): Для всех вызовов еще память для хранения самой матрицы -  ((m + 1) * (n + 1)) * sizeof(int) \begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  2 * sizeof(int)
		\item ссылка на матрицу - 8 байт
		\item адрес возврата
	\end{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна(для каждого вызова):\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательная переменная -  sizeof(int)
		\item адрес возврата
	\end{itemize}
\end{itemize}


\section*{Вывод}

Рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 10 символов, матричная реализация алгоритма нахождения расстояния Левенштейна превосходит по времени работы рекурсивную на несколько порядков.

Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и сравним по времени работы с матричными алгоритмами. 

Алгоритм нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна. В нём добавлена дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно дольше, чем алгоритм нахождения расстояния Левенштейна.

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
