# Трудоемкость

Трудоемкость алгоритмов умножения матриц, сортировки

Модель оценки трпудоемкости (вычислений)

1. Трудоемкость базовых вычислений

Пусть трудоемкость равна 2: `%, /, *`
Трудоемкость единична: `+ - = += == < > <= >= != >> << [] ++ --`

2. Трудоемкость цикла

\[ f_c = f_{init} + f_{comparison} + N_{iter} * ( f_{body} + f_{inc} + f_{cmp} ) \]

\( f_{init} \) - `int i = 0;`

```c

// 1 + 3 + N/2(1 + 3 + f_body)
for (int i = 0; i < N/2; i++)
{

}
```

> В ЛР 2, 3 нужно отключить оптимизации компилятора.

3. Трудоемкость условного оператора
Пусть стоимость условного перехода = 0
Тогда оценим трудоемкость для следующего фрагмента кода

\[ f_{if} = f_{comp} + \begin{cases} min(f1, f2)  - best\\ max(f1, f2) - worst \end{cases} \]

Оценка трудоемкости дается по наиболее быстро растущему слагаемому, в зависимости от линейного размера входа (входов)

Тут пример умножения матриц но я его не записал

Трудоемкость оптимизированного алгоритма умножения матриц

Его порядок \(11 * M * N * Q \)

## Алгоритм Винограда

\[ c_{ij} = (u_1, u_2, u_3) \cdot (w_1, w_2, w_3) ^ T = (u_1 + w_2) * (u_2 * w_1) + (u_3 * w_4) * (u_4 * w_3) - (u_1 * u_2 + u_3*u_4 + w_1 * w_2 + w_3 * w_4) \]

\( (u_1 * u_2 + u_3*u_4 + w_1 * w_2 + w_3 * w_4) \) - вычисляется один раз

Тут всего **два** умножения, но нужно два массива для хранения u_1 * u_2 + u_3 * u_4, ...

Введем \( mulH, mulV \), где будут храниться элементы выше

\(A : M \times Q \)

### Часть 1 - заполнение mulH

```cpp
for (int i = 0; i < M; i++)
{
    for (int k = 0; k < N/2; k++)
    {
        mulH[i] = mulH[i] + A[i][2*k] * A[i][2*k+1]
    }
}
```

\[ f_{I} = 2 + M * (2 + 4 * N/2(4+15)) = 19 / 2 * M * N  + 6 M + 2\]

Оптимизация:

```cpp
        mulH[i] += A[i][2*k] * A[i][2*k+1]
```

```cpp
    for (int k = 0; k < N; k+=2)
    {
        mulH[i] = mulH[i] + A[i][k] * A[i][k+1]
    }
```

\[ 2*M + 2 * M * N / 2 + 2 * 2 * M * N / 2 = \]
\[ 5.5 M * N + 4 * M + 2 \]

### Часть 2 - заполнение mulH

аналогично \( f_{II} = 5.5 Q * N + 4Q + 2 \)

```cpp

for (int i = 0; i < M; i++)
{
    for(int j = 0; j < Q; J++)
    {
        C[i][j] = - MulH[i] - MulV[j];
        for (int k = 0; k < N/2; k++)
        {
            C[i][j] = C[i][j] + (A[i*2*k] + B[2 * k + 1][j]) * (A[i][2*k+1] + B[2*k][j])
        }
    }
}
```

```cpp

for (int i = 0; i < M; i++)
{
    for(int j = 0; j < Q; J++)
    {
        C[i][j] = - MulH[i] - MulV[j];
        for (int k = 0; k < N; k++)
        {
            C[i][j] +=(A[i*k] + B[i * k + 1][j]) * (A[i][i*k+1] + B[i*k][j])
        }
    }
}
```

\[ f_{III} = 2 + M * (2 + 2 + 2(2 + 7 + 4 * N/2(4 + 12 * 1 ([]) + 1*1(=) + 5 * 1(+) + 5 * 2(*)))) \]
\[ f_{III} = 32 / 2 M * N * Q + 13 * M * Q + 4 * M + 2 \]

\[ f_{III} \approx 19/2 M * N * Q \]

Оптимизация еще одна

```cpp
    for(int j = 0; j < Q; J++)
    {
        buf = - MulH[i] - MulV[j];
        for (int k = 0; k < N; k++)
        {
            buf +=(A[i*k] + B[i * k + 1][j]) * (A[i][i*k+1] + B[i*k][j])
        }
        C[i][j] = buf
    }
```
\[ f_{III} \approx 17/2 M * N * Q \]

Что если матрицы нечетные?
Нужно добавить доп. слагаемое

Часть 4, нужно добавить + u_5 * w_5 к сумме. Это плохо

```c
if (N % 2 == 1)
{
    for(int i = 0; i < M; i++)
    {
        for (int j = 0; j < Q; j++)
        {
            C[i][j] += A[i][N-1] * B[N-1][j];
        }
    }
}
```

\[ f_{IV} = 3 + \begin{cases} 0, N \% 2 = 0 \\ 2 \cdot M (2 + 2 + Q * (2 * 14)) \end{cases} \]

## Задание лаб 2

Трудоемкость алгоритмов умножения матриц

Требуется проанализировать стандартный алгоритм и алгоритм винограда.
Требуется разработать и реализовать алгоритмы

1. Стандартный
2. Винограда
3. Винограда оптимизированный нами (3+ типы оптимизации)

Конструкторская - схемы алгоритмов

Листинги

Оценить трудоемкость всех трех алгосов
Указать когда лучший и худший случай
С нас полный вывод формул

Получить общую формулу, сказать какое самое бысто растущее слагаемое

Время замерить,

6 графиков, 3 для лучшего, 3 для худшего

В кострукторской части отдельно указать каждое улучшение и описать кумулятивный эффект

Отключить оптимизаци
