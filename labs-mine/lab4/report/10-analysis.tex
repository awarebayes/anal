\chapter{Аналитическая часть}
В этом разделе будут представлены описание отличий работы GPU от CPU, описание работы растеризатора, а также применение параллельных вычислений в растеризаторе.

Понятия stream и thread кардинально отличаются, в то время как перевод на русский отображает эти два различных понятия в одно единственное слово 'поток'. Чтобы избежать путаницы, условимся обозночать потоком thread.

\section{Работа графического ускорителя}

Начнем со сравнения работы центрального процессора (ЦП, host) и графического ускорителя (device).

В центральном процессоре каждое ядро может выполнять свои инструкции. Каждое ядро центрального процессора обладает своим отдельным программным стеком, секциями data, code, и т.д. Видеокарта реализует парадигму SIMT - Single Instruction Multiple Threads. 
Согласно ей, каждый поток в группе выполняет одну и ту же инструкцию. Поэтому видеокарта может выполнять большее количество инструкций за такт, чем центральный процессор.
Это достигается за счет того, что ядра видеокарты устроены проще ядер центрального процессора. У них отсутствует возможность спекулятивного выполнения, контейнерной обработки, виртуальной организации памяти, как итог блока TLB.

Минимальной единицей диспетчеризации программирования на ЦП является поток. Минимальной единицей диспетчеризации на видеокарте является варп. В современных архитектурах варп полагается равным 32 потокам. При попытке запустить меньшее количество потоков n, остальные 32-n потоков будут простаивать.
Каждый поток в варпе выполняется отдельным ядром. Каждый варп управляется Streaming Multiprocessor (SM). Таким образом аналогом ядра процессора является SM, он может сам решать, какие инструкции ему выполнять. Это существенно отличается от архитектуры SIMT, где потоки выполняют только те инструкции, которые они получат. Видеокарта обладает большим количеством SM. В современных архитектурах количество SM может быть от 8 до 80. Количество SM определяется архитектурой видеокарты. Например, в архитектуре Kepler количество SM равно 15. В архитектуре Ampere количество SM равно 80.
Недостатком данного подхода является феномен расхождения варпов (warp divergence). Когда управление программы (control flow) встречает условие, при котором одни потоки должны выполнять одни инструкции, а другие - альтернативные. SM сначала дает инструкции для выполнения первой группе, пока вторая их игнорирует. Далее SM дает инструкции второй группе, пока первая их игнорирует. Таким образом, при неправильном структурировании программы, можно получить замедление в 2 раза.

Каждый Streaming Multiprocessor может выполнять свои задачи асинхронно.

\section{Примитивы Cuda для работы с ускорителем}

CUDA (изначально аббр. от англ. Compute Unified Device Architecture) — программно-аппаратная архитектура параллельных вычислений, которая позволяет существенно увеличить вычислительную производительность благодаря использованию графических процессоров фирмы Nvidia.
CUDA SDK позволяет программистам реализовывать на специальных упрощённых диалектах языков программирования Си, C++ и Фортран алгоритмы, выполнимые на графических и тензорных процессорах Nvidia

Для понимания некоторых техник программирования, использующихся в дальнейшем, важно понимать некоторые примитивы, предоставляемые разработчику Cuda.
Cuda использует модель параллелизма на задачах (task parallelism).
Очередью задач называется Stream, задачи из нескольких Stream могут выполняться одновременно. Каждый Stream может выполняться на отдельном SM. Стандартным подходом к использованию Stream API является раздача задач набору из Stream, после которой происходит ожидание выполнения всех задач.

Функции, предназначенные для исполнения на видеокарте называются kernel. 

Графический ускоритель зачастую является отдельным девайсом (как можно понять по названию), подсоединяемым в слот PCI-E. Как результат, он имеет свою память (видеопамять), отдельную от центрального процессора. 
Копирование памяти Host-Device (например вызов memcpyDtoH) - очень затратная операция, которой мы стараемся избегать. Это связано с большим количеством вызовов ioctl и ожидания futex. Использование Page-Locked страниц памяти позволяет выполнять некоторые операции совместно, с участием девайся DMA.
Диспетчеризация запуска kernel является быстрой операцией.

\section{Растеризатор}

Растеризация это перевод изображения, описанного векторным форматом в пиксели или точки, для вывода на дисплей или принтер. Процесс, обратный векторизации.
Мы рассматриваем растеризацию трехмерной модели. Модель состоит из вершин (точек в 3х мерном пространстве) и граней (наборов ребер соединяющий вершины).
Ключевая возможность параллелизации заключается в параллельном преобразовании каждой вершины и в параллельной отрисовке каждой грани на растре.

Введем понятие виртуальной геометрии как геометрии (набора вершин и граней), отсутствующей в описании модели. 
Виртуальная геометрия генерируется автоматически, процедурно усложняя детали модели. Модель, целиком состоящую из виртуальной геометрии будем называть виртуальной моделью.
Проблемой работы растеризатора является расхождение варпов, при отрисовке треугольников разного размера. Все потоки в варпе, кроме последнего могут закончить отрисовку треугольников, в то время как последний будет блокировать другие потоки своей работой.
Я решаю эту проблему использованием виртуальной геометрии.
Реализован параллельный анализ отрисовываемых граней, создание новых моделей с виртуальной геометрией.

\section*{Вывод}

Были введены ключевые понятия предметной области GPGPU. Рассмотрена работа видеоускорителя, поведение ключевых примитивов API Cuda.
Выявлены проблемы, возможные способы их решения. На высоком уровне описаны ключевые детали работы растеризатора.