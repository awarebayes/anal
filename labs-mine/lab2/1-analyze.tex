\chapter{Аналитическая часть}
В этом разделе будут произведена формализация задачи, а также 
рассмотрены существующие алгоритмы умножения матриц и модель для
оценки трудоёмкости алгоритмов.

\section{Формализация задачи}
Матрица - математический объект, записываемый в виде прямоугольной таблицы, который представляет
собой совокупность строк и столбцов, на пересечениях которых находятся элементы. Количество строк
и столбцов задаёт размер матрицы.

Над матрицами определены несколько основных операций, в том числе умножение. Матрицы $A$ и $B$ 
могут быть перемножены, если число столбцов матрицы $A$ равняется числу строк $B$.

Пусть матрица $A$ имеет размеры $L \times M$, а матрица $B$ -- $M \times N$. Тогда результирующая матрица
$C$ имеет размеры $L\times N$, а каждый элемент матрицы можно подсчитать по формуле \ref{first}:
\begin{equation}
	\label{first}
	C_{i, j} = \sum\limits_{r=1}^M a_{ir} * b_{rj}   (i\in[1, L]; j\in[1, N])
\end{equation}

\section{Классический алгоритм умножения матриц}
Классический алгоритм реализует формулу умножения матриц в прямом виде. Для каждого элемента
подсчитывается значение независимо от других вычислений. Преимущество этого алгоритма состоит 
в простоте реализации, а также в отсутствии дополнительных затрат на память. Но недостаток заключается
в том, что в алгоритме присутствует три полных цикла, и затраты по времени составляют $O(n^3)$. 
Реализация становится слишком затратной, поэтому были созданы другие алгоритмы умножения матриц.

\section{Алгоритм Винограда}
Подход алгоритма Винограда является иллюстрацией общей методологии, начатой в 1979 годах на основе билинейных и трилинейных форм, 
благодаря которым было получено большинство усовершенствований для умножения матриц \cite{vino}.

Рассмотрим два вектора $V = (v1, v2, v3, v4)$ и $W = (w1, w2, w3, w4)$.  

Их скалярное произведение равно (\ref{formula}) 

\begin{equation} 
	V \cdot W=v_1 \cdot w_1 + v_2 \cdot w_2 + v_3 \cdot w_3 + v_4 \cdot w_4
	\label{formula}
\end{equation}

Равенство (\ref{formula}) можно переписать в виде:
\begin{align*} 
	V \cdot W=(v_1 + w_2) \cdot (v_2 + w_1) + (v_3 + w_4) \cdot (v_4 + w_3) - \\
	v_1 \cdot v_2 - v_3 \cdot v_4 - w_1 \cdot w_2 - w_3 \cdot w_4
	\label{formula2}
\end{align*}

Действий вычисления одного значения стало больше, но выражение в правой части последнего равенства допускает предварительную обработку:
его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй.

Это означает, что над предварительно обработанными элементами нам придется выполнять лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения. В сравнении с классическим алгоритмом, где для вычисления скаляров требовалось четыре умножения и четыре сложения, получается выигрыш как
в количестве действий, так и в быстродействии программы, так как сложение выполняется быстрее, чем умножение.

К недостатку алгоритма можно отнести дополнительные затраты на память, так как для каждой строки первой матрицы 
и для каждого столбца второй матрицы хранится значение в массиве.

\section{Оптимизированный алгоритм Винограда}
Оптимизированный алгоритм Винограда представляет собой обычный алгоритм Винограда, за исключением следующих оптимизаций:
\begin{itemize}
	\item вычисление происходит заранее;
	\item используется битовый сдвиг, вместо деления на 2;
	\item последний цикл для нечётных элементов включён в основной цикл, используя дополнительные операции в случае нечётности N.
\end{itemize}

\section*{Вывод}
Была произведена формализация задачи и рассмотрены основные существующие алгоритмы умножения матрицы.